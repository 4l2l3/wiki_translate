h1. Advanced Submit Techniques


This document provides information on job submission techniques that do not fall into the standard serial/parallel model and need additional considerations.  If you know of any other techniques that can be helpful, please let us know so we can include them here.

h2. SGE Array Tasks
!GridEngine provides a mechanism to allow users to submit a single job which will be spawned as a range of tasks.  Lets say you have a problem such as the following:
** You are using a parallel application that runs best on 8 processors
** You have 48 different data sets you need to run with this application
** You cannot iterate the execution of the parallel job within your submit script, like
<pre>
#$ -N my_app
#$ -cwd
#$ -l h_rt=10:00:00,pcpus=8

for i in {1..48}; do
      mpirun -np $NSLOTS ./my_app inputfile.$i
done
</pre>
because the scheduler will not permit such behavior.  You are allowed one and only one parallel run per job.

With !GridEngine, you can tell the scheduler that your job is an array task.  To do this, you'll need to add the *-t* option to your submit script.  Here's and example:
<pre>
#$ -N my_app_array_run
#$ -cwd
#$ -l h_rt=00:45:00,pcpus=8
#$ -t 1-48

mpirun -np $NSLOTS ./my_app inputfile.$SGE_TASK_ID
</pre>

You can now arrange your input files, inputfile, as inputfile.[1-48].  With the -t option, !GridEngine will execute your submit script 48 times.  The only difference between these jobs will be the value of $SGE_TASK_ID which you can use to direct your application to the correct data sets.

A slightly more complex example uses $SGE_TASK_ID as an index variable to define, for example, a temperature range.  Say you want to calculate some property of a system at various temperatures.  It is unnecessary to generate all of the input files before hand if you are incrementing through a temperature range.  This can be done on the fly with a little shell scripting and regular expressions:

<pre>
#$ -N my_app_array_run
#$ -cwd
#$ -l h_rt=00:45:00,pcpus=8
#$ -t 1-10

# Set the new temperature
BASE_TEMP=100
TEMP=`bc -q <<EOF
scale=2
$BASE_TEMP+($SGE_TASK_ID/10)
EOF`
sed -r "s/TEMP(\s)+\=(\s)+([0-9])+\.([0-9])+/TEMP = $TEMP" inputfile.template > inputfile.$SGE_TASK_ID

mpirun -np $NSLOTS ./my_app inputfile.$SGE_TASK_ID
</pre>

This will allow you to automatically generate your input file for every run by substituting a line in the template input file with a new line declaring the temperature you wish to work with.

h2. Iterative Parallel Jobs
The Iterative Parallel job is similar to the job described above, but each iteration must be run in sequence because each subsequent run of your application depends upon some data element generated by the previous run.  As before, since the scheduler cannot do something like this:

<pre>
#$ -N my_app
#$ -cwd
#$ -l h_rt=10:00:00,pcpus=8

for i in {1..48}; do
      mpirun -np $NSLOTS ./my_app inputfile.$i
done
</pre>

we are stuck with a problem: How do we run an iterative parallel job without having to modify inputs and resubmit a new job after each iteration?

h3. Job Dependencies
With creative use of !GridEngine's array task throttling facility, we can ensure a sort of "blocking" behavior between each run of your job.  As you can see in the example below, we have created a submit script which extracts necessary data from previous runs in order to create the parameters for our subsequent runs.  This script is for a hypothetical example and will need to be modified to suit your needs:

<pre>
#$ -cwd
#$ -l h_rt=00:45:00,pcpus=8
#$ -N myjob
#$ -t 1-10
#$ -tc 1

# Lets take a specific result from the previous run and the first run
# to form the basis of the next run
if [ $ITR -gt 1 ]; then
     NEW_PARAM_1=`awk '/^RESULT.*\=.*[0-9]+\.[0-9]+$/ { print $NF}' output.$NAME.$((SGE_TASK_ID - 1))
     NEW_PARAM_2=`awk '/^RESULT.*\=.*[0-9]+\.[0-9]+$/ { print $NF}' output.$NAME.1 | \

     # Generate our new input file
     sed -r "s/PARAMETER1(\s)+\=(\s)+([0-9])+\.([0-9])+/PARAMETER1 = $NEW_PARAM_1/" \
                inputfile.template > inputfile.$JOB_NAME.$SGE_TASK_ID
     # Do the replacement 'inline' to the existing inputfile
     sed -ri "s/PARAMETER2(\s)+\=(\s)+([0-9])+\.([0-9])+/PARAMETER2 = $NEW_PARAM_2/" \
                inputfile.$JOB_NAME.$SGE_TASK_ID
fi

mpirun -np $NSLOTS ./my_app inputfile.$JOB_NAME.$SGE_TASK_ID
</pre>

We can submit the following like so, to run 10 steps:
<pre>
[user@host ~]$ qsub myjob.sh
</pre>

In this example, we parse out a particular figure from the previous run's output (defined as @output.$JOB_NAME.$((SGE_TASK_ID - 1))@ and we use that value as a parameter in our next run.
